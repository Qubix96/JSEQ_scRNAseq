---
title: "JSEQ RAPORT"
date: "`r Sys.Date()`"
output: html_document
---


```{r include=FALSE}
library(Seurat)
library(tidyverse)
library(patchwork)
library(gridExtra)
library(grid)
library(knitr)
library(viridis)


```

\

### Below is a REPORT on the Single cell Dataset Analysis. All operations were performed using the JSEQ pipeline. For more information about the performed operations, please read the JSEQ Manual.

\

```{r message=FALSE, warning=FALSE, include=FALSE}
args <- commandArgs()

path <- args[6]
markers <-args[7]
species <- args[8]
seurat_umi <- file.path(path,'sc_data/')
path_results <- file.path(path, 'results')
project_name <- args[9]
data <- args[10]
functions <- file.path(getwd(), 'scripts/functions.R')
source(functions)

path_tmp <- file.path(path, 'tmp')

UMI <- readRDS(file = file.path(OUTPUT, "Results.rds"))
n_gen <- as.numeric(quantile(UMI@meta.data$nGenes, 0.75))
cells_number <- length(UMI@active.ident)

metrics <- file.path(path_tmp,'scRNAmetrics.txt')
chceck_fq <- grepl("_fq", metrics)
```

\

# Single Cell analysis for `r species`

\

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}

if (chceck_fq == TRUE){
mydata <- read.csv(file = metrics, header = T,
                   stringsAsFactors = F, skip = 6, sep = "\t")
mydata <- mydata[order(mydata$PF_ALIGNED_BASES, decreasing = T), ]
mydata_pct <- mydata[, c("READ_GROUP",
                         "PCT_INTERGENIC_BASES",
                         "PCT_UTR_BASES",
                         "PCT_RIBOSOMAL_BASES",
                         "PCT_INTRONIC_BASES",
                         "PCT_CODING_BASES")
                     ]
colnames(mydata_pct) = c('Cell Barcode', 'Intergenic', 'UTR', 'Ribosomial', 'Intronic', 'Coding')

mydata <- mydata[, c("READ_GROUP",
                     "INTERGENIC_BASES",
                     "UTR_BASES",
                     "RIBOSOMAL_BASES",
                     "INTRONIC_BASES",
                     "CODING_BASES")
                 ]
colnames(mydata) = c('Cell Barcode', 'Intergenic', 'UTR', 'Ribosomial', 'Intronic', 'Coding')

# converting into long format for ploting
mydata_long <- mydata %>% gather("Read Overlap", count, -"Cell Barcode")

# Keep the original order of the barcodes using factor and levels.
mydata_long$`Cell Barcode` <- factor(mydata_long$`Cell Barcode`,
                                 levels = factor(unique(mydata_long$`Cell Barcode`)))
mydata_long$`Read Overlap` <- factor(mydata_long$`Read Overlap`,
                                   levels = unique(mydata_long$`Read Overlap`))

p1 <- ggplot(mydata_long, aes(x = `Cell Barcode`, y = count, fill = `Read Overlap`)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0), legend.position = "none")
p1 <- p1 + labs(title = "The content of individual parts of genetic elements",
                x = "Barcodes", y = "Bases")
p1 <- p1 + theme(axis.title.x = element_blank(),
                 axis.text.x = element_blank(),
                 axis.ticks.x = element_blank())
p1 <- p1 + scale_y_continuous(labels = scales::scientific)
p1 <- p1 + scale_fill_viridis(discrete = TRUE, option = "viridis")


mydata_long_pct <- mydata_pct %>% gather("Read Overlap", fraction, -"Cell Barcode")
# Keep the original order of the barcodes using factor and levels.
mydata_long_pct$`Cell Barcode` <- factor(mydata_long_pct$`Cell Barcode`,
                                     levels = factor(unique(mydata_long_pct$`Cell Barcode`)))
mydata_long_pct$`Read Overlap` <- factor(mydata_long_pct$`Read Overlap`,
                                       levels = unique(mydata_long_pct$`Read Overlap`))

p2 <- ggplot(mydata_long_pct, aes(x = `Cell Barcode`, y = fraction, fill = `Read Overlap`)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 90, hjust = 0, size=8, vjust = 0.05), legend.position = "bottom") +
  labs(x = "Barcodes", y = "%Bases") +
  scale_y_continuous(labels = scales::percent) + scale_fill_viridis(discrete = TRUE, option = "viridis")


p1

}
```


```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}

if (chceck_fq == TRUE) {
p2
}
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
if (chceck_fq == TRUE){
cat('Knee plot with threshold for detected unique barcodes and set number of cells ##')
}
```

```{r pressure, echo=FALSE, out.width = '70%', fig.align="center"}

if (chceck_fq == TRUE){
  
knitr::include_graphics(file.path(path_results,'expect_whitelist_cell_barcode_counts.png'), dpi = 300)
  
}
``` 


```{r echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

if (chceck_fq == TRUE){
  
cat('The above plots show content of genetics elements for each cells (barcodes). The number of cells is provided by the user estimation. To check that number provided number of cells is correct you can look at knee plot, which shows distugushe between estimated number of cells via user and detected unique barcodes. When the values are very different you can change number of cells and conduct analysis from the begining but before you do this, you have to create new project with right settings')

}
```

\

## Number of genes and counts in analysis

\

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}
VlnPlot(UMI, features = c("nGenes", "nCounts"), ncol = 2)
```

\

### The ratio of the number of genes to the number of counts

\
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}

FeatureScatter(UMI, feature1 = "nCounts", feature2 = "nGenes")

```


\
\

## Percent of ribosomal and mitochondrial genes [%]


\

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}

VlnPlot(UMI, features = c("RiboPercent", "MitoPercent"), ncol = 2)

```


```{r message=FALSE, warning=FALSE, include=FALSE}

{

QC_UMI <- data.frame()
QC_UMI <- as.data.frame(UMI$nGenes)
QC_UMI$V2 <- UMI$MitoPercent
QC_UMI$V3 <- UMI$RiboPercent

colnames(QC_UMI) <- c('nGenes','MitoPercent','RiboPercent')

QC_UMI$Mito_Status[QC_UMI$MitoPercent > 5] <- '> 5%'
QC_UMI$Mito_Status[QC_UMI$MitoPercent <= 5] <- 'Proper'

QC_UMI$nGenes_Status[QC_UMI$nGenes < 200] <- 'Empty'
QC_UMI$nGenes_Status[QC_UMI$nGenes > n_gen] <- 'Double'
QC_UMI$nGenes_Status[QC_UMI$nGenes >= 200 & QC_UMI$nGenes <= n_gen] <- 'Proper'

QC_UMI$Ribo_Status[QC_UMI$RiboPercent == 0] <- '0%'
QC_UMI$Ribo_Status[QC_UMI$RiboPercent > 0] <- '> 0 %'
}

```


\

## Quality Control of droplets content


```{r echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

if (chceck_fq == TRUE){
cat('Graphs presents information about cells unique feature counts. There was filtered droplets with over 2,500 (more than one cell in droplet) or less than 200 (empty droplet) counts per droplet and droplets that have >5% mitochondrial counts.')
}
```

\

### Number of counts

\

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}

ggplot()+
  geom_point(QC_UMI, mapping = aes(x = nGenes, y = nGenes, color = nGenes_Status))+
  ylab("Number of genes for each cells") +
  xlab("Number of genes for each cells")+
  theme(axis.text.x = element_text(angle = 50, vjust = 1, hjust=1))+
  labs(color='Droplet content') 

```

\

### Mitogenes counts

\

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}
ggplot()+
  geom_point(QC_UMI, mapping = aes(x = MitoPercent, y = MitoPercent , color = Mito_Status))+
  ylab("% MitoRNA") +
  xlab("% MitoRNA")+
  theme(axis.text.x = element_text(angle = 50, vjust = 1, hjust=1))+
  labs(color='% Content treshold') 
```


\

### Roibogenes counts

\

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}
ggplot()+
  geom_point(QC_UMI, mapping = aes(x = RiboPercent, y = RiboPercent, color = Ribo_Status))+
  ylab("% RiboRNA") +
  xlab("% RiboRNA")+
  theme(axis.text.x = element_text(angle = 50, vjust = 1, hjust=1))+
  labs(color='% Content treshold') 

```

\
\

## Selection of highly variable genes
### Top10
\

```{r echo=FALSE, message=FALSE, warning=FALSE}

top10 <- head(VariableFeatures(UMI), 10)
top10

```

\

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}

plot1 <- VariableFeaturePlot(UMI)
LabelPoints(plot = plot1, points = top10, repel = TRUE)


```

\

```{r message=FALSE, warning=FALSE, include=FALSE}

Elbow <- ElbowPlot(UMI)

dims <- as.data.frame(Elbow$data$stdev)

#select the most variable reduction

{
  dim <- c()
  score <- c()
  element <- 0
  for (i in dims$`Elbow$data$stdev`) {
    element <- element + 1
    score <- cbind(i)
    print(dims$`Elbow$data$stdev`[element+1])
    print(i)
    if (i-0.05*i >= dims$`Elbow$data$stdev`[element+1]) {
      dim <- element
    } else break
  }
  
  
  dim <- as.numeric(dim)
}

```


\

### Graph presentation of selection right number of PCs

\

### ElbowPlot

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}
Elbow
```

\

### JackStrawPlot for `r dim` PCs

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}
JackStrawPlot(UMI, dims = 1:(dim+1))
```

\

### Graphs with summary for `r dim` PCs as the primary sources of heterogeneity in a dataset

\

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}

DimHeatmap(UMI, dims = 1:dim, cells = cells_number, balanced = TRUE)


```

\

## Cell nameing and clustering

### UMAP and PCA plot after cell naming

\

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}

DimPlot(UMI, reduction = "umap") + DimPlot(UMI, reduction = "pca")

```

\

### Tree plot of clusters

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}

tree_cluster <- Tool(object = UMI, slot = 'BuildClusterTree')
plot(tree_cluster)

```

\

### Pheatmap of selected cell types and top variables genes for clusters

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}
UMI.markers <- FindAllMarkers(UMI, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)

{
  top10 <- data.frame(top10$cluster, top10$gene)
  colnames(top10) <- c('cluster','gene')
  
  
  all_unique('top10','[1:2]','cluster')
  
  top10$cluster <- top10$Group.1
  top10 <- top10[,-1] 
}

top10 <- UMI.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_logFC)
top_genes <- top10$gene[[1]]
index <- 1
for (i in 2:nrow(top10)){
  index <- index + 1
  top_genes <- c(top_genes, top10$gene[[index]])
}

average_expression <- read.csv(file.path(path_tmp, "average_expression_matrix_populations.csv"), header = T, row.names = 1)
average_expression <- as.data.frame(average_expression)
phet_exp_matrix <- average_expression[rownames(average_expression) %in% top_genes,]

pheatmap::pheatmap(phet_exp_matrix, 
                          clustering_method = 'complete', 
                          cluster_rows = F)
```

\
\

## Manualy analysis

```{r echo=FALSE, message=FALSE, warning=FALSE, results='asis'}


cat('You can also run analysis manually. In this project in ',path_results,' directory was saved SeuratObject in two forms: before analysis (Seurat_object.rds) and after analysis (Results.Rds). Read one in to R (preferable IDE RStudio) and run your own analysis with parameters suitable for you.')

```
\
\